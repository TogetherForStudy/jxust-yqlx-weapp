# 幂等性实现说明

## 概述

根据 `api_design.md` 中的要求，项目已实现请求头 `X-Request-ID` 和 `X-Idempotency-Key` 的自动添加机制，并特别针对快速重复点击问题进行了优化。

## 实现细节

### 1. X-Request-ID（请求追踪 ID）

**功能**：为每个请求生成唯一的追踪 ID

**实现方式**：
- 每次请求自动生成一个新的 UUID v4 格式的请求 ID
- 如果请求头中已存在 `X-Request-ID`，则不会覆盖
- 用于日志追踪和问题排查

**适用范围**：所有请求（GET、POST、PUT、DELETE、PATCH 等）

### 2. X-Idempotency-Key（幂等性密钥）

**功能**：防止写操作的重复提交

**实现方式**：基于请求内容的智能缓存机制

#### 2.1 幂等性 Key 生成策略

对于相同的写操作（相同的方法、URL 和请求体），会使用**相同的幂等性 Key**，直到请求完成或超时。

**缓存标识生成**：
```javascript
标识 = `${METHOD}:${URL}:${JSON.stringify(data)}`
```

**示例**：
- 请求 1：`POST:/api/v0/reviews:{"content":"很好"}`
- 请求 2：`POST:/api/v0/reviews:{"content":"很好"}` （相同标识，使用相同 Key）
- 请求 3：`POST:/api/v0/reviews:{"content":"不错"}` （不同标识，使用新 Key）

#### 2.2 缓存生命周期

| 阶段 | 时长 | 说明 |
|-----|------|------|
| **活跃期** | 请求开始 ~ 请求完成 | 同一标识的请求使用相同 Key |
| **保护期** | 请求完成后 5 分钟 | 防止短时间内的意外重复 |
| **过期清理** | 超过 10 分钟 | 自动清理，释放内存 |

#### 2.3 Key 清除机制

幂等性 Key 会在以下情况被清除：

1. **请求成功**：立即清除，允许后续相同内容的新请求
2. **请求失败**：立即清除，允许用户重试
3. **超时保护**：5分钟后自动清除（避免 Key 永久占用）

#### 2.4 防止快速重复点击

**场景示例**：用户快速点击"提交评价"按钮 3 次

```
时间轴：
0ms:  第1次点击 → 生成 Key: abc-123 → 发送请求
100ms: 第2次点击 → 复用 Key: abc-123 → 发送请求
200ms: 第3次点击 → 复用 Key: abc-123 → 发送请求
500ms: 请求返回成功 → 清除 Key
```

**后端行为**：
- 第1个请求：正常处理，返回结果
- 第2个请求：检测到相同 Key，返回第1个请求的缓存结果（`X-Idempotency-Replayed: true`）
- 第3个请求：同上

**结果**：虽然前端发送了 3 次请求，但后端只处理了 1 次，避免重复数据

### 3. 适用范围

| HTTP 方法 | X-Request-ID | X-Idempotency-Key | 说明 |
|-----------|--------------|-------------------|------|
| GET | ✅ | ❌ | 读操作不需要幂等性保护 |
| POST | ✅ | ✅ | 创建操作需要防重 |
| PUT | ✅ | ✅ | 更新操作需要防重 |
| DELETE | ✅ | ✅ | 删除操作需要防重 |
| PATCH | ✅ | ✅ | 部分更新需要防重 |
| HEAD | ✅ | ❌ | 读操作不需要幂等性保护 |
| OPTIONS | ✅ | ❌ | 读操作不需要幂等性保护 |

## 代码位置

所有实现都在 `src/utils/request.js` 中：

1. **UUID 生成器**：`generateUUID()`
2. **缓存管理**：
   - `idempotencyKeyCache` - 缓存对象
   - `generateRequestIdentifier()` - 生成缓存标识
   - `getOrCreateIdempotencyKey()` - 获取或创建 Key
   - `clearIdempotencyKey()` - 清除 Key
3. **请求拦截器**：`interceptors.request()`
4. **通用请求方法**：`request()`

## 使用示例

### 自动使用（推荐）

无需修改任何业务代码，所有 API 调用都会自动添加正确的请求头：

```javascript
import { reviewAPI } from '../api'

// 创建评价 - 自动添加幂等性保护
await reviewAPI.createReview({
  teacher_id: 123,
  content: '很好的老师'
})

// 即使用户快速点击 3 次，后端也只会创建 1 条评价
```

### 手动指定（特殊场景）

如果需要手动控制幂等性 Key（例如：跨页面保持相同的 Key）：

```javascript
import { post } from '../utils/request'

// 手动指定 X-Idempotency-Key
await post('/api/v0/reviews', data, {
  header: {
    'X-Idempotency-Key': 'my-custom-key-12345'
  }
})
```

## 最佳实践

### ✅ 推荐做法

1. **让框架自动处理**：不要手动添加请求头，除非有特殊需求
2. **UI 反馈**：提交时禁用按钮，提升用户体验
3. **错误重试**：失败后可以安全重试，Key 会被清除

### ❌ 避免的做法

1. **不要在短时间内修改数据后重试**：会被识别为不同请求
2. **不要在客户端缓存幂等性 Key 超过 1 分钟**：可能与服务器不同步
3. **不要手动管理幂等性 Key**：除非你完全理解其工作原理

## 性能考虑

### 内存占用

- 每个缓存项约 200 字节（Key + 时间戳 + 标识符）
- 假设 1000 个并发请求 = 约 200KB 内存
- 自动清理机制确保不会无限增长

### 清理策略

- **主动清理**：请求完成后立即清除
- **被动清理**：每 2 分钟清理过期项（超过 2 分钟）
- **保护期**：1 分钟内的重复请求会被拦截

## 常见问题

### Q1: 为什么用户修改内容后重新提交会生成新的评价？

**A**: 这是正常行为。不同的内容会生成不同的缓存标识，被视为不同的请求。

### Q2: 如果用户在不同页面提交相同内容会怎样？

**A**: 会被识别为相同请求，使用相同的幂等性 Key，后端会返回第一次的结果。

### Q3: 请求失败后多久可以重试？

**A**: 立即可以重试。失败的请求会立刻清除幂等性 Key。

### Q4: 如何在后端日志中追踪请求？

**A**: 使用响应中返回的 `RequestId` 字段，它与请求头中的 `X-Request-ID` 对应。

### Q5: 是否需要担心缓存爆炸？

**A**: 不需要。自动清理机制会在 2 分钟后清理所有过期缓存。

## 技术细节

### UUID v4 格式

使用标准的 UUID v4 格式：
- 格式：`xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx`
- 版本位：第 13 位固定为 `4`
- 变体位：第 17 位为 `8`、`9`、`a` 或 `b`
- 示例：`550e8400-e29b-41d4-a716-446655440000`

### 缓存数据结构

```javascript
{
  'POST:/api/v0/reviews:{"content":"很好"}': {
    key: '550e8400-e29b-41d4-a716-446655440000',
    timestamp: 1733556292773
  }
}
```

## 测试建议

### 单元测试场景

1. **快速重复点击**：验证使用相同 Key
2. **不同内容**：验证生成不同 Key
3. **请求完成**：验证 Key 被清除
4. **超时清理**：验证过期项被清理
5. **失败重试**：验证失败后可重试

### 集成测试场景

1. **提交表单 → 快速点击 → 只创建一条记录**
2. **提交成功 → 修改内容 → 提交 → 创建新记录**
3. **提交失败 → 重新提交 → 成功创建**

## 更新日志

- **2024-12-07**：初始实现，支持基于请求内容的智能幂等性保护
